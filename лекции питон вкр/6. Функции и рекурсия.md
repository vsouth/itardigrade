Понятия: функция, процедура, параметры, возвращаемое значение. Рекурсивные функции. Базовый, рекурсивный случаи. Решение задач 16, 19, 20, 21, 23.

### Понятия

#### Функция
Функция - это блок кода, который выполняет определенную задачу и может быть вызван из других частей программы. Она может принимать аргументы (параметры) и возвращать результат.

**Синтаксис в Python:**
```python
def function_name(parameters):
    # код функции
    return result
```

**Пример:**
```python
def greet(name):
    return "Hello, " + name

print(greet("Alice"))
```
**Вывод:**
```
Hello, Alice
```


#### Параметры
Параметры - это значения, передаваемые функции при её вызове. Функция может использовать параметры для выполнения определенных операций.

#### Возвращаемое значение
Возвращаемое значение - это результат работы функции, который она возвращает в место её вызова.

#### Процедура
Процедура - это функция, которая не возвращает значения, а просто выполняет определенные действия.

**Синтаксис в Python:**
```python
def procedure_name(parameters):
    # код процедуры
```

**Пример:**
```python
def print_hello():
    print("Hello, world!")

print_hello()
```
**Вывод:**
```
Hello, world!
```

### Рекурсивные функции

Рекурсивная функция - это функция, которая вызывает саму себя в своем определении. Она обычно имеет два случая: базовый случай (когда рекурсия завершается) и рекурсивный случай (когда функция вызывает саму себя).

**Базовый случай** - это условие, при котором рекурсия прекращается.

**Рекурсивный случай** - это условие, при котором функция вызывает саму себя для решения подзадачи.

**Пример рекурсивной функции:**

```python
def factorial(n):
    if n == 0:
        return 1
    else:
        return n * factorial(n - 1)

print(factorial(5))  # Вывод: 120
```

В данном примере `factorial()` - рекурсивная функция, которая вычисляет факториал числа. Базовый случай - когда `n` равно 0, функция возвращает 1. Рекурсивный случай - когда `n` больше 0, функция вызывает саму себя для вычисления факториала `(n - 1)` и умножает результат на `n`.

### Виды рекурсии

#### 1. Прямая рекурсия

Это классический случай, когда функция вызывает саму себя напрямую. Примером может быть рекурсивная функция для вычисления факториала, как показано выше.

**Условие задачи:** Напишем рекурсивную функцию для вычисления суммы всех элементов списка.

**Код на Python:**
```python
def sum_list(lst):
    if not lst:
        return 0  # Базовый случай: если список пуст, возвращаем 0
    else:
        return lst[0] + sum_list(lst[1:])  # Рекурсивный случай: суммируем первый элемент списка со суммой оставшихся элементов

# Пример использования функции
my_list = [1, 2, 3, 4, 5]
print("Сумма всех элементов списка:", sum_list(my_list))
```

#### 2. Косвенная рекурсия

Это случай, когда функция вызывает другую функцию, которая в свою очередь вызывает первую функцию. Такая ситуация возникает, когда функции вызывают друг друга циклически.

**Условие задачи:** Рассмотрим две функции, одна из которых вызывает другую, а другая вызывает первую. Напишем пример такой косвенной рекурсии.

**Код на Python:**
```python
def even(n):
    if n == 0:
        return True
    else:
        return odd(n - 1)

def odd(n):
    if n == 0:
        return False
    else:
        return even(n - 1)

# Пример использования функций
print("Число 4 четное?", even(4))
print("Число 5 четное?", even(5))
```

#### 3. Хвостовая рекурсия

Это особый случай, когда рекурсивный вызов функции является последней операцией в теле функции. В этом случае, компилятор или интерпретатор может оптимизировать код, чтобы избежать накопления стека вызовов. В Python стандартная реализация не поддерживает оптимизацию хвостовой рекурсии, но некоторые интерпретаторы, такие как PyPy, могут выполнять такую оптимизацию.

**Условие задачи:** Напишем рекурсивную функцию для вычисления факториала числа, используя хвостовую рекурсию.

**Код на Python:**
```python
def factorial_tail(n, acc=1):
    if n == 0:
        return acc  # Базовый случай: если n равно 0, возвращаем аккумулятор
    else:
        return factorial_tail(n - 1, acc * n)  # Рекурсивный случай: умножаем аккумулятор на текущее значение n и вызываем функцию с (n-1)

# Пример использования функции
print("Факториал числа 5:", factorial_tail(5))
```

#### 4. Нерекурсивная рекурсия

Это не строго рекурсивный подход, но он использует структуру данных, такую как стек, для эмуляции рекурсии. Вместо того, чтобы вызывать функцию саму себя, эта структура данных хранит состояние, которое позволяет продолжать выполнение функции с того места, где она была приостановлена.

**Условие задачи:** Напишем рекурсивную функцию для вычисления чисел Фибоначчи без использования прямой рекурсии.

**Код на Python:**
```python
def fibonacci(n):
    fib_sequence = [0, 1]  # Начальные значения чисел Фибоначчи

    # Заполняем список числами Фибоначчи
    for i in range(2, n + 1):
        fib_sequence.append(fib_sequence[-1] + fib_sequence[-2])

    return fib_sequence[n]

# Пример использования функции
print("Число Фибоначчи под номером 6:", fibonacci(6))
```

### Как писать рекурсивные алгоритмы:

1. **Определите базовый случай**: Это условие, при котором рекурсия должна прекратиться. Без базового случая рекурсивная функция будет вызывать саму себя бесконечно.

2. **Определите рекурсивный случай**: Это условие, при котором функция вызывает саму себя для решения подзадачи. Важно, чтобы рекурсивный случай приближал к базовому случаю.

3. **Обработка параметров**: Убедитесь, что каждый рекурсивный вызов изменяет параметры таким образом, чтобы рекурсия двигалась к базовому случаю.

4. **Проверка на остановку**: Убедитесь, что рекурсия в конечном итоге достигает базового случая. В противном случае может возникнуть бесконечная рекурсия, что приведет к переполнению стека вызовов.

5. **Тестирование**: Проверьте свою рекурсивную функцию на различных входных данных, чтобы убедиться, что она ведет себя корректно и завершается при различных условиях.

### Способы реализации рекурсии

Рекурсия может быть реализована двумя основными способами: "сверху вниз" (top-down) и "снизу вверх" (bottom-up). Эти термины описывают направление, в котором рекурсивные вызовы происходят и как результаты сохраняются.

#### Рекурсия сверху вниз (Top-down)

**Описание:** В этом подходе рекурсивная функция начинает с наивысшего уровня задачи и рекурсивно разбивает её на более мелкие подзадачи, пока не достигает базовых случаев. Вместо того чтобы непосредственно вычислять решение для базовых случаев, функция рекурсивно вызывает себя для решения этих меньших подзадач.

**Применение:** Этот подход часто используется в комбинированных рекурсивных алгоритмах, где результаты могут быть сохранены (например, в словаре для мемоизации), чтобы избежать повторных вычислений.

**Пример:** Рекурсивное вычисление чисел Фибоначчи с мемоизацией (`fibonacci_top_down`).

**Условие задачи:** Напишем функцию для вычисления чисел Фибоначчи, используя рекурсивный подход "сверху вниз" с мемоизацией.

**Код на Python:**
```python
def fibonacci_top_down(n, memo={}):
    if n in memo:
        return memo[n]
    if n <= 1:
        return n

    # Рекурсивно вычисляем числа Фибоначчи с мемоизацией
    memo[n] = fibonacci_top_down(n - 1, memo) + fibonacci_top_down(n - 2, memo)
    return memo[n]

# Пример использования функции
print("Число Фибоначчи под номером 6:", fibonacci_top_down(6))
```


#### Рекурсия снизу вверх (Bottom-up)

**Описание:** В этом подходе рекурсивная функция начинает с базовых случаев и рекурсивно комбинирует их, чтобы получить решение для большего набора данных, постепенно двигаясь к исходной задаче.

**Применение:** Этот подход часто используется в динамическом программировании, когда решение задачи можно выразить через решения её подзадач, и когда необходимо избежать рекурсивных вызовов в пользу итерации.

**Пример:** Рекурсивное вычисление чисел Фибоначчи "снизу вверх" с использованием массива для хранения промежуточных результатов (`fibonacci_bottom_up`).

**Условие задачи:** Напишем функцию для вычисления чисел Фибоначчи, используя метод динамического программирования "снизу вверх".

**Код на Python:**
```python
def fibonacci_bottom_up(n):
    fib_sequence = [0, 1]  # Начальные значения чисел Фибоначчи

    # Вычисляем числа Фибоначчи снизу вверх
    for i in range(2, n + 1):
        fib_sequence.append(fib_sequence[-1] + fib_sequence[-2])

    return fib_sequence[n]

# Пример использования функции
print("Число Фибоначчи под номером 6:", fibonacci_bottom_up(6))
```


Оба подхода имеют свои преимущества и недостатки, и выбор конкретного подхода зависит от конкретной задачи и структуры данных.

- **Сверху вниз (top-down):** Этот подход хорошо подходит, когда вы имеете дело с проблемами, которые могут быть разбиты на более мелкие подзадачи и когда повторные вычисления могут быть оптимизированы с помощью мемоизации. Это часто используется в комбинаторных задачах и задачах оптимизации.

- **Снизу вверх (bottom-up):** Этот подход эффективен, когда решение задачи может быть выразительно представлено через решения её подзадач. Это часто применяется в динамическом программировании и когда требуется избежать переполнения стека вызовов.

#### Как соотносятся эти подходы с видами рекурсии:

1. **Прямая рекурсия:** Этот вид рекурсии соответствует как рекурсии "сверху вниз", так и "снизу вверх". В прямой рекурсии функция вызывает саму себя, прямо или через промежуточные функции.

2. **Косвенная рекурсия:** Этот вид рекурсии проявляется, когда одна функция вызывает другую, а затем она возвращает вызов обратно к первой функции. Этому типу рекурсии соответствует подход "сверху вниз", когда одна функция вызывает другую и та, в свою очередь, вызывает первую.

3. **Хвостовая рекурсия:** Этот вид рекурсии проявляется, когда рекурсивный вызов является последней операцией в функции. Это позволяет оптимизировать рекурсию в итерацию. Хвостовая рекурсия соответствует как "снизу вверх", так и "нерекурсивной" рекурсии, особенно когда используется техника хвостовой оптимизации для преобразования рекурсивного вызова в цикл.

4. **Нерекурсивная рекурсия:** Этот термин может быть немного противоречивым, поскольку рекурсия по определению включает вызов функции самой себя. Однако в контексте "нерекурсивной" рекурсии мы можем подразумевать подход, при котором рекурсивный алгоритм имитируется без прямого вызова функции самой себя. Этому подходу соответствует, например, использование циклов вместо рекурсивных вызовов для вычисления результата.

#### Мемоизация в Python

В Python для мемоизации функций можно использовать декоратор `functools.lru_cache` из стандартной библиотеки `functools`. Этот декоратор добавляет в функцию кэширование с ограниченным размером кэша, что позволяет сохранять результаты выполнения функции для предотвращения повторных вычислений.

Вот как можно использовать `functools.lru_cache` для мемоизации функции:

```python
from functools import lru_cache

@lru_cache(maxsize=None)  # Указываем None для неограниченного размера кэша
def fibonacci(n):
    if n <= 1:
        return n
    else:
        return fibonacci(n-1) + fibonacci(n-2)

# Пример использования
print(fibonacci(10))  # Печатает 55
```

Декоратор `@lru_cache` автоматически сохраняет результаты вычислений в кэше и использует их при повторных вызовах функции с теми же аргументами.

Опция `maxsize=None` указывает, что кэш не имеет ограничений на размер. Вы можете установить конкретный размер кэша, передав значение в `maxsize`, но обычно нет необходимости в этом, если вы не работаете с огромными объемами данных.

Этот метод мемоизации удобен и эффективен, так как он автоматически управляет кэшем и использует его для предотвращения повторных вычислений функции.


### Решение задачи 16

#### Условия задачи:
Есть функция F(n), где n – натуральное число, которая вычисляется следующим образом:
F(n)=n при n<11;
F(n)=n+F(n–1), если n≥11.
Чему равно значение выражения F(2024)−F(2021)?
#### Решение:
Код на Python:
```python
f = [i for i in range(0, 11)]
for i in range(11, 2025):
    f.append(i + f[-1])
print(f[2024] - f[2021])
```
Ответ: 6069.


### Решение задачи 19

#### Условия задачи:
Петя и Ваня играют в игру, где они добавляют или удваивают количество камней в куче. Цель - получить 129 или больше камней. За один ход игрок может добавить в кучу один камень или увеличить количество камней в куче в два раза. Для того чтобы делать ходы, у каждого игрока есть неограниченное количество камней. Нужно найти минимальное количество камней в начальной куче, при котором Петя не может выиграть за один ход, но Ваня может выиграть своим первым ходом.
#### Решение:
Код на Python:
``` python
def f(n, turn):
    if turn == 3 and n >= 129:
        return 1
    elif turn == 3 and n < 129:
        return 0
    elif n >= 129 and turn < 3:
        return 0
    else:
        if turn % 2 == 0:
            # стратегия победителя
            return f(n + 1, turn + 1) or f(n * 2, turn + 1) 
        else:
            # стратегия проигравшего
            return f(n + 1, turn + 1) and f(n * 2, turn + 1)
for x in range(1, 129):
    if f(x, 1) == 1:
        print(x)
        break
```
Ответ: 64.


### Решение задачи 20

#### Условия задачи:
Для игры, описанной в задании 19, найдите два наименьших значения S, при которых у Пети есть выигрышная стратегия:
•	Петя не может выиграть за один ход;
•	Петя может выиграть своим вторым ходом независимо от стратегии Вани.
Значения S запишите в порядке возрастания.
#### Решение:
Код на Python:
``` python
def f(n, turn):
    if turn == 4 and n >= 129:
        return 1
    elif turn == 4 and n < 129:
        return 0
    elif n >= 129 and turn < 4:
        return 0
    else:
        if turn % 2 != 0:
            # стратегия победителя
            return f(n + 1, turn + 1) or f(n * 2, turn + 1) 
        else:
            # стратегия проигравшего
            return f(n + 1, turn + 1) and f(n * 2, turn + 1)
for x in range(1, 129):
    if f(x, 1) == 1:
        print(x)
```
Ответ: 32 63.


### Решение задачи 21

#### Условия задачи:
Для игры, описанной в задании 19, найдите минимальное значение S:
•	у Вани есть выигрышная стратегия, благодаря которой при любой игре Пети он выиграет первым или вторым ходом;
•	у Вани нет стратегии, которая позволит ему гарантированно выиграть первым ходом.
В ответ запишите минимальное значение S.
#### Решение:
Код на Python:
``` python
def f(n, turn):
    if (turn == 3 or turn == 5) and n >= 129:
        return 1
    elif turn == 5 and n < 129:
        return 0
    elif n >= 129 and turn < 5:
        return 0
    else:
        if turn % 2 == 0:
            # стратегия победителя
            return f(n + 1, turn + 1) or f(n * 2, turn + 1)
        else:
            # стратегия проигравшего
            return f(n + 1, turn + 1) and f(n * 2, turn + 1)
def f1(n, turn):
    if turn == 3 and n >= 129:
        return 1
    elif turn == 3 and n < 129:
        return 0
    elif n >= 129 and turn < 3:
        return 0
    else:
        if turn % 2 == 0:
            # стратегия победителя
            return f1(n + 1, turn + 1) or f1(n * 2, turn + 1)
        else:
            # стратегия проигравшего
            return f1(n + 1, turn + 1) and f1(n * 2, turn + 1)
for x in range(1, 129):
    if f(x, 1) == 1:
        print(x)
print("За исключением:")
for x in range(1, 129):
    if f1(x, 1) == 1:
        print(x)
```
Ответ: 62.


### Решение задачи 23

#### Условия задачи:
У исполнителя Калькулятора, преобразующего натуральное число, есть следующие команды:
А. Прибавить 3.
Б. Прибавить 2.
С. Умножить на 2.
Первая команда увеличивает число на 3, вторая – на 2, третья – умножает на 2. Сколько существует таких программ, которые исходное число 1 преобразуют в число 50, и при этом точно известно, что каждая вторая команда – Б, а количество команд при выполнении программы нечётно?
В ответ запишите количество программ.
#### Решение:
Код на Python:
``` python
def f(n, goal, k):
    if n >= goal:
        return (n == goal) and (k % 2 != 0)
    if k % 2 != 0:
        return f(n + 2, goal, k + 1)
    return f(n + 3, goal, k + 1) + f(n + 2, goal, k + 1) + f(n * 2, goal, k + 1)
print(f(1, 50, 0))
```
Ответ: 1669.

