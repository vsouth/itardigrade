Сложность алгоритма. Обзор и повторение подходов к решению алгоритмических задач: полный перебор, жадные алгоритмы, подход «Разделяй и властвуй», динамическое программирование. Метод «Скользящего окна». Решение задачи 24.

### Сложность алгоритма:

Сложность алгоритма - это мера ресурсов, необходимых для его выполнения, таких как время и память. Она обычно измеряется в терминах входных данных. Существует два основных типа сложности:

1. **Временная сложность:** Описывает количество операций или время, необходимое для выполнения алгоритма в зависимости от размера входных данных.
2. **Пространственная сложность:** Описывает количество памяти, необходимое для выполнения алгоритма в зависимости от размера входных данных.
**O-нотация (Big O Notation):** Описывает верхнюю границу временной или пространственной сложности алгоритма в худшем случае. Например, O(n) означает, что сложность алгоритма линейная, O(log n) - логарифмическая, O(n^2) - квадратичная и так далее.
### Примеры:

1. **Линейная сложность (O(n)):** Алгоритм, который выполняет операции с каждым элементом входных данных один раз, имеет линейную сложность. Например, просмотр всех элементов в массиве.
    
2. **Квадратичная сложность (O(n^2)):** Алгоритм, который выполняет операции для каждого элемента входных данных с каждым другим элементом, имеет квадратичную сложность. Например, сортировка выбором.
    
3. **Логарифмическая сложность (O(log n)):** Алгоритм, который уменьшает размер входных данных примерно вдвое на каждом шаге, имеет логарифмическую сложность. Например, двоичный поиск в отсортированном массиве.
    
4. **Константная сложность (O(1)):** Алгоритм, который выполняет постоянное количество операций, независимо от размера входных данных, имеет константную сложность. Например, доступ к элементу массива по индексу.
![](Pasted%20image%2020240421213732.png)
### Обзор подходов к решению алгоритмических задач:

**Полный перебор (Brute Force):**
   - Этот метод заключается в проверке всех возможных вариантов решения задачи.
   - Обычно используется для небольших входных данных из-за высокой временной сложности.
   ```python
   # Пример полного перебора для поиска максимального элемента в списке
   def max_element(nums):
       max_num = float('-inf')
       for num in nums:
           if num > max_num:
               max_num = num
       return max_num
   ```
   **Рекомендации**:
     - Убедитесь, что количество возможных вариантов не слишком велико, иначе алгоритм будет неэффективным.
     - Используйте структуры данных и алгоритмы для оптимизации процесса перебора, например, сортировку.
     - При необходимости можно применять отсечение (pruning) для исключения ненужных вариантов.
     - Обратите внимание на возможные оптимизации после написания базового алгоритма.

**Жадные алгоритмы (Greedy Algorithms):**
   - Этот подход выбирает локально оптимальное решение на каждом шаге с надеждой на то, что это приведет к глобально оптимальному решению.
   - Жадные алгоритмы обычно эффективны и легко реализуются, но не всегда гарантируют оптимальное решение.
   ```python
   # Пример жадного алгоритма для задачи о рюкзаке
   def knapsack(weights, values, capacity):
       n = len(weights)
       max_value = 0
       for i in range(n):
           if weights[i] <= capacity:
               max_value += values[i]
               capacity -= weights[i]
       return max_value
   ```
**Рекомендации**:
     - Убедитесь, что жадный выбор на каждом шаге действительно ведет к оптимальному решению.
     - Проанализируйте, какие критерии или метрики использовать для принятия локальных оптимальных решений.
     - Проверьте, не приведет ли жадный выбор к локальным оптимумам, которые не являются глобальными.
     - При наличии нескольких критериев выбора, рассмотрите их приоритеты и влияние на конечное решение.

**Подход «Разделяй и властвуй» (Divide and Conquer):**
   - Этот подход разбивает задачу на более мелкие подзадачи, решает их рекурсивно, а затем объединяет решения подзадач в общее решение.
   - Часто используется для оптимизации временной сложности за счет уменьшения размера входных данных на каждом шаге.
   ```python
   # Пример алгоритма быстрой сортировки, основанного на подходе "Разделяй и властвуй"
   def quicksort(arr):
       if len(arr) <= 1:
           return arr
       pivot = arr[len(arr) // 2]
       left = [x for x in arr if x < pivot]
       middle = [x for x in arr if x == pivot]
       right = [x for x in arr if x > pivot]
       return quicksort(left) + middle + quicksort(right)
   ```
   **Рекомендации**:
     - Разбейте задачу на подзадачи так, чтобы они были достаточно просты для решения, но при этом не перекрывались друг с другом.
     - Убедитесь, что выход из рекурсии гарантирован и не приведет к зацикливанию.
     - Проанализируйте, как объединить решения подзадач для получения решения исходной задачи.
     - При необходимости используйте дополнительную память или структуры данных для оптимизации процесса объединения решений.

**Динамическое программирование (Dynamic Programming):**
   - "Разделяй и властвуй" разбивают задачу на более мелкие подзадачи и используют решения подзадач, чтобы собрать решение для главной. Во время этого процесса количество подзадач может стать очень большим, и некоторые алгоритмы решают одну и ту же подзадачу многократно, что чрезмерно увеличивает время выполнения. Динамическое программирование упорядочивает вычисления и позволяет не вычислять уже известные значения повторно.
   - Этот метод решает задачу, разбивая ее на подзадачи, решение каждой из которых сохраняется для последующего использования.
   - Обычно используется для оптимизации временной сложности за счет избегания повторных вычислений.
   ```python
   # Пример динамического программирования для нахождения чисел Фибоначчи
   def fibonacci(n):
       if n <= 1:
           return n
       memo = [0] * (n + 1)
       memo[1] = 1
       for i in range(2, n + 1):
           memo[i] = memo[i - 1] + memo[i - 2]
       return memo[n]
   ```
### Метод "Скользящего окна" (Sliding Window):

Метод "Скользящего окна" используется для решения задач, связанных с подстроками или подмассивами, и заключается в том, чтобы обрабатывать элементы или символы в массиве или строке поочередно, не пересчитывая предыдущие результаты.

Пример использования метода "Скользящего окна" для нахождения подстроки с максимальной суммой в массиве:

```python
def max_subarray_sum(nums, k):
    window_sum = sum(nums[:k])
    max_sum = window_sum
    for i in range(k, len(nums)):
        window_sum = window_sum - nums[i - k] + nums[i]
        max_sum = max(max_sum, window_sum)
    return max_sum
```

Этот метод позволяет решать задачи с временной сложностью O(n), где n - размер массива или строки, что делает его эффективным для решения определенного класса задач.

### Решение задачи 24.

#### Условия задачи:
Текстовый файл состоит из букв латинского алфавита и десятичных цифр. Нужно найти максимальную длину подстроки, которая начинается и заканчивается цифрами разной чётности, но при этом не содержит внутри других цифр.
В ответе запишите максимальную длину такой подстроки.
#### Решение:
Код на Python:
``` python
filename = "24.txt"
digits = "0123456789"
with open(filename) as file:
    data = file.readline()
    left_pointer = 0
    max_length = 0
    for right_pointer, symbol in enumerate(data):
        if symbol not in digits:
            continue
        if (
            data[left_pointer] in digits
            and int(symbol) % 2 != int(data[left_pointer]) % 2
        ):
            max_length = max(max_length, right_pointer - left_pointer + 1)
        left_pointer = right_pointer
print(max_length)
```
Ответ: 49.
